---
title: "2. 线程管控"
date: 2024-09-08
---

# 线程的基本管控
## 发起线程
```cpp
// 任何可调用类型都适用于std::thread，包括函数指针、函数对象、lambda等
void do_something();

class Task {
public:
    void operator()() const {
        cout << "in object Task\n";
    }
};

std::thread t1(do_something);
std::thread t2(t);
std::thread t3([]{ std::cout << "in lambda\n"; });
```
---
将函数对象传递给`std::thread`的构造函数时，要注意防范所谓的“C++最麻烦的解释”（C++'s most vexing parse）。若传入的是临时变量，那么调用构造函数的语法可能与函数声明相同。这种情况编译器会将其解释成函数声明，而不是定义对象
```cpp
class Task {
public:
    void operator()() const {
        cout << "in object Task\n";
    }
};

// 这种情形下编译器会报错。因为它认为下面这行是声明一个函数，而不是定义一个thread对象。
// 因此在调用join()方法时会出错。
std::thread t1(Task());
t1.join();

// 改成如下形式就没问题
std::thread t1{Task()};
// 或
std::thread t1((Task()));
```
---
一旦启动了线程，我们就必须明确是等待它结束（join），还是让它独自运行（detach）。若等到`std::thread`对象销毁时还没决定好，那么`std::thread`的析构函数就会调用`std::terminate()`终止整个程序。
假设程序不等待线程结束，那么在线程运行结束前，我们需要保证它所访问的外部数据始终有效。
```cpp
class Task {
public:
    Task(int i_): i(i_) {}
    void operator()() const {
        for (int j = 0; j < 1000000; j++) {
            do_something(i);
        }
    }
    int& i;
};

// 在oops退出后，线程t可能仍在运行，但此时local_val已被销毁，导致未定义行为
void oops() {
    int local_val = 0;
    Task task(local_val);
    std::thread t(task);
    t.detach();
}
```
上述情形的处理方法通常是：令线程函数完全自含（self-contained），将数据复制到新线程内部，而不是共享数据。

## 等待线程完成
若需等待线程完成，那么可以在与之关联的`std::thread`上，通过调用成员函数`join()`来实现。
对于某个给定的线程，`join()`只能调用一次；事实上，只要`std::thread`对象曾经调用过`join()`，线程就不再可汇合（joinable），成员函数`joinable()`将返回`false`。

## 在出现异常的情况下等待
避免抛出异常而导致程序终结，我们需要处理这种情况。

```cpp
// 利用RAII等待线程完结
class ThreadGuard {
private:
    std::thread& t;
public:
    explicit ThreadGuard(std::thread& t_): t(t_) {}
    // 禁用拷贝构造和拷贝赋值
    ThreadGuard(const ThreadGuard&)=delete;
    ThreadGuard& operator=(const ThreadGuard&)=delete;
    // 析构时调用join()，如果t是joinable的话
    ~ThreadGuard() {
        if (t.joinable()) {
            t.join();
        }
    }
};
```

## 在后台运行线程
```cpp
// 调用detach()，会令线程在后台运行
std::thread t(do_something);
t.detach();
t.joinable() // false
```

# 向线程函数传递参数
