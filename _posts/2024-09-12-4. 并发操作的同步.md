---
title: "4. 并发操作的同步"
date: 2024-09-12
---
# 等待事件或等待其他条件
如果线程A要等待线程B完成某任务，可以采取不同方式。
1. 在共享数据内部设置标志位，B完成后，就设置该标志成立
2. 让A调用`std::this_thread::sleep_for()`函数
3. 使用C++标准库工具等待事件发生。（推荐）

## 凭借条件变量等待条件成立
C++提供了条件变量的2种实现：
1. [`std::condition_variable`](https://zh.cppreference.com/w/cpp/thread/condition_variable)，仅限于与`std::mutex`一起使用
2. [`std::condition_variable_any`](https://zh.cppreference.com/w/cpp/thread/condition_variable_any)，只要某一类型符合成为互斥的最低标准，就可以配合使用。但可能产生额外开销，因此**不应**优先使用。
```cpp
#include <thread>
#include <mutex>
#include <condition_variable>
#include <queue>
#include <atomic>
#include <iostream>

std::mutex m;
std::queue<int> data_queue;
std::condition_variable cond;
std::atomic<bool> flag{true};

void data_prepare() {
    int count = 10;
    while (flag) {
        int data = 10;
        {
            std::scoped_lock lock(m);
            data_queue.push(data);
        }
        cond.notify_one();
        count--;
        if (count == 0) {
            flag.store(false);
        }
    }
}

void data_process() {
    int count = 0;
    while (true) {
        std::unique_lock lock(m);
        cond.wait(lock, []{return !data_queue.empty();});
        int data = data_queue.front();
        data_queue.pop();
        std::cout << "get data " << data << std::endl;
        count++;
        if (count == 10) {
            std::cout << "process all data" << std::endl;
            break;
        }
    }
}

int main() {
    std::thread t1(data_prepare);
    std::thread t2(data_process);

    for (int i = 0; i < 10; i++){}

    t1.join();
    t2.join();
    return 0;
}
```
---
`std::condition_variable::wait`本质是忙等待的优化。以下是`wait()`的一种合法实现
```cpp
template <typename Predicate>
void wait(std::unique_lock<std::mutex>& lock, Predicate pred) {
    while (!pred()) {
        lk.unlock();
        lk.lock();
    }
}
```

## 利用条件变量构建线程安全的队列
略

# 使用`future`等待一次性事件发生
C++使用`future`来模拟这样一类事件：若线程需要等待某个特定的**一次性**事件发生，则会以恰当的方式获取一个`future`，它代表目标事件；接着，线程就能一边处理其他事务一边等待，同时，它以短暂的间隔反复检查目标事件是否发生。

C++有两种`future`：
* 独占`future`，即`std::future<>`
* 共享`future`，即`std::shared_future<>`

## 从后台任务返回值
```cpp
#include <thread>
#include <stdio.h>
#include <future>
#include <vector>

long dot_mul(std::vector<int>& lhs, std::vector<int>& rhs, size_t size) {
    int ret = 0;
    for (size_t i = 0; i < size; i++) {
        ret += lhs[i] * rhs[i];
    }
    return ret;
}

void do_other(void) {
    printf("doing other staff....\n");
}

int main() {
    std::vector<int> a(1000);
    std::vector<int> b(1000);

    for (int i = 0; i < 1000; i++) {
        a[i] = i;
        b[i] = 1000 - i;
    }

    std::future<long> res = std::async(&dot_mul, std::ref(a), std::ref(b), 1000);
    do_other();
    printf("result is %ld\n", res.get());

    return 0;
}
```

## 关联`future`实例和任务