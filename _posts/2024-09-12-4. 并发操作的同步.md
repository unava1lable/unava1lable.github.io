---
title: "4. 并发操作的同步"
date: 2024-09-12
---
# 等待事件或等待其他条件
如果线程A要等待线程B完成某任务，可以采取不同方式。
1. 在共享数据内部设置标志位，B完成后，就设置该标志成立
2. 让A调用`std::this_thread::sleep_for()`函数
3. 使用C++标准库工具等待事件发生。（推荐）

## 凭借条件变量等待条件成立
C++提供了条件变量的2种实现：
1. [`std::condition_variable`](https://zh.cppreference.com/w/cpp/thread/condition_variable)，仅限于与`std::mutex`一起使用
2. [`std::condition_variable_any`](https://zh.cppreference.com/w/cpp/thread/condition_variable_any)，只要某一类型符合成为互斥的最低标准，就可以配合使用。但可能产生额外开销，因此**不应**优先使用。
```cpp
#include <thread>
#include <mutex>
#include <condition_variable>
#include <queue>
#include <atomic>
#include <iostream>

std::mutex m;
std::queue<int> data_queue;
std::condition_variable cond;
std::atomic<bool> flag{true};

void data_prepare() {
    int count = 10;
    while (flag) {
        int data = 10;
        {
            std::scoped_lock lock(m);
            data_queue.push(data);
        }
        cond.notify_one();
        count--;
        if (count == 0) {
            flag.store(false);
        }
    }
}

void data_process() {
    int count = 0;
    while (true) {
        std::unique_lock lock(m);
        cond.wait(lock, []{return !data_queue.empty();});
        int data = data_queue.front();
        data_queue.pop();
        std::cout << "get data " << data << std::endl;
        count++;
        if (count == 10) {
            std::cout << "process all data" << std::endl;
            break;
        }
    }
}

int main() {
    std::thread t1(data_prepare);
    std::thread t2(data_process);

    for (int i = 0; i < 10; i++){}

    t1.join();
    t2.join();
    return 0;
}
```
---
`std::condition_variable::wait`本质是忙等待的优化。以下是`wait()`的一种合法实现
```cpp
template <typename Predicate>
void wait(std::unique_lock<std::mutex>& lock, Predicate pred) {
    while (!pred()) {
        lk.unlock();
        lk.lock();
    }
}
```

## 利用条件变量构建线程安全的队列
略

# 使用`future`等待一次性事件发生